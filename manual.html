<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible><title>Bagatto</title><meta content="width=device-width, initial-scale=1.0" name=viewport><meta content itemprop=author name=author><meta name=description content="Bagatto: a transparent, extensible static site generator"><link href=/images/48.png rel=icon sizes=48x48 type=image/png><link href=/images/128.png rel=icon sizes=128x128 type=image/png><link href=/images/256.png rel=icon sizes=256x256 type=image/png><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Adamina&family=Raleway:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet async><link href=static/site.css rel=stylesheet type=text/css async></head> <body> <div> <div> <div class="mw8 center pv7 cf"> <div class=fl> <div class=ph3> <h1 class="f1 ma0 title"> Bagatto </h1> <p class=mv3> A transparent, extensible static site generator </p> </div> <nav role=navigation> <ul class="list pl0 ma0 lh-copy"> <li class="dib mr2"> <a class="pv2 ph3 fw6 nav focus-black" href=index.html>Bagatto</a> </li> <li class="dib mr2"> <a class="pv2 ph3 fw6 nav focus-black" href=getting.html>Getting Bagatto</a> </li> <li class="dib mr2"> <a class="pv2 ph3 fw6 nav focus-black" href=manual.html>Manual</a> </li> <li class="dib mr2"> <a class="pv2 ph3 fw6 nav focus-black" href=guides.html>Guides</a> </li> <li class="dib mr2"> <a class="pv2 ph3 fw6 nav focus-black" href=api.html>API</a> </li> <li class="dib mr2"> <a href=https://sr.ht/~subsetpark/bagatto/ class="pv2 ph3 fw6 nav focus-black">Source</a> </li> </ul> </nav> <div class="ph3 mt5 guide mw8"> <h1 id=thebagattomanual>The Bagatto Manual</h1> <p>Z. D. Smith, Brooklyn, NY, 2020.</p> <h1 id=usage>Usage</h1> <p>Bagatto operates in two phases: the <strong>data</strong> phase and the <strong>site</strong> phase.</p> <p>In the data phase, Bagatto will read a data specification and use it to create a table containing all the input data. Data specifications that consist of literal attributes will result in site data containing those same attributes. Specifications of a single file path will result in site data pertaining to the one file. Specifications of a file wildcard will result in an array of data objects, one for each file that matches the wildcard.</p> <p>In the site phase, Bagatto will read the site specification and use it to generate a sequence of files. Each site specification will ultimately specify the <strong>path</strong> and <strong>contents</strong> of one or more files. Bagatto will then ensure the presence of each file path and ensure that its contents are as specified.</p> <h2 id=replmode>REPL Mode</h2> <p>We can enter a REPL environment that allows us to explore the index module by using the <code>--repl</code> flag to <code>bag</code>. This enters a Janet REPL with three helper functions injected: <code>eval-data</code>, <code>eval-site</code>, and <code>write-site</code>. These represent the three main steps of executing Bagatto: generating site data, generating site &#8220;write specifications&#8221;, and writing the specified files.</p> <p>Here&#8217;s a short example using the <code>basic-site</code> demo:</p> <pre><code class=clj>code-src/bagatto/demo/basic-site [master !] âŠ• bag --repl index.janet 
repl:1:&gt; (eval-data data)
Reading config data spec...
Reading pages data spec...
Reading css data spec...
Beginning 3 jobs...
Loaded config
Loading pages...
[pages] Loading 2 files
Loading css (styles.css)...
Finished jobs.
@{:config {:author &quot;Z. D. Smith&quot; 
           :description &quot;A minimal website&quot; 
           :title &quot;Bagatto Demo&quot;} 
  :pages @[@{:basename &quot;about&quot; 
             :path &quot;pages/about.md&quot; 
             :contents @&quot;...&quot;} 
           @{:basename &quot;bagatto&quot; 
             :path &quot;pages/bagatto.md&quot; 
             :contents @&quot;...&quot;}] 
  :css @{:path &quot;styles.css&quot; 
         :contents @&quot;...&quot;}}
</code></pre> <h2 id=thebagattoapi>The Bagatto API</h2> <p>The <code>bag</code> command accepts a single filename as an argument. This is known as the <strong>index module</strong>, and it should be syntactically correct Janet. One of the principles of Bagatto is to go as far as is practicable to make the operation of the Janet language inside the index module as similar as possible to any other use of the Janet interpreter or compiler.</p> <p>Thus, there&#8217;s only one real difference between programming inside an index module and writing a normal Janet module: Bagatto inserts a couple useful libraries into the namespace so that we, as the site authors, don&#8217;t need to manage these libraries in order to use them inside the module.</p> <p>They are:</p> <ul> <li>The <a href=./api.html#bagatto-api><code>bagatto</code></a> library itself, a collection of useful functions designed to reduce boilerplate in Bagatto modules, whose API is listed below;</li> <li>The <a href=https://github.com/janet-lang/path><code>path</code></a> library, which exposes functions for manipulating file paths;</li> <li>The <a href=https://github.com/andrewchambers/janet-sh><code>janet-sh</code></a> library, which exposes a useful DSL for shelling out to the command line.</li> </ul> <p>One of Bagatto&#8217;s principles is to expose as much of its API as possible in the form of ordinary functions to be used to produce the data structures you define in your index module. There are a couple places where that isn&#8217;t possible, and where we have to expose a &#8220;global&#8221; API instead.</p> <p>In addition to the helper functions exposed in the <code>bagatto/</code> namespace, there are a few features that can be accessed directly inside of index modules:</p> <h3 id=defaultshandling>Defaults Handling</h3> <p>Bagatto exposes the <code>bagattto/set-defaults!</code> function, which can be called at any point inside an index module. It takes a single argument: a struct or dictionary specifying the default value for any of the specification attributes: <code>:src</code>, <code>:attrs</code>, <code>:dest</code>, <code>:out</code>.</p> <h3 id=outputdirectory>Output Directory</h3> <p>By calling <code>bagatto/set-output-dir!</code>, you can specify the directory that Bagatto should write its generated file tree into. This is principally exactly the same as appending that directory name to every path that you generate; however, if you use this feature then you can re-use paths in your business logic (for instance, you can define a path value and use it when generating a file, and when rendering a link in your site), as the additional file hierarchy will be transparently dealt with.</p> <h2 id=data>Data</h2> <p>Your Bagatto module should expose a <strong>data specification</strong> like this:</p> <pre><code class=clj>(def data ... )
</code></pre> <p>This value will be used as the starting point by the Bagatto application. Its job is to specify all the inputs that should go into the system.</p> <p>The <code>data</code> value should be a struct where the keys are <strong>data specification names</strong> and the values are the specifications themselves. The data specification names are meaningful, as they are referred to by the site specifications, as we&#8217;ll see.</p> <h3 id=dataliterals>Data Literals</h3> <p>The simplest form of a data specification is a literal struct or table, like this:</p> <pre><code class=clj>(def data {:config {:attrs {:title &quot;A Demo Bagatto Config&quot;}}})
</code></pre> <p>When Bagatto creates the <em>site data</em> for this specification, it will consist of a single key-value pair:</p> <pre><code class=clj>repl:13:&gt; (eval-data data)
@{:config {:title &quot;A Demo Bagatto Config&quot;}}
</code></pre> <h3 id=filereferences>File References</h3> <p>The next type of data specification is a reference to a single file in the project. These will consist of two attributes, <code>:src</code>, which specifies the location of the file with respect to the current working directory, and <code>:attrs</code>, which contains a function that will be called with the file contents, like this:</p> <pre><code class=clj>(def data {:config-json {:src &quot;config.json&quot;
                         :attrs bagatto/parse-json}}
</code></pre> <p>(Theoretically, you could pass in a data literal as above in this case too, but in that case the file would be ignored and there wouldn&#8217;t be much point.)</p> <p>In this case, Bagatto will look for a file called <code>config.json</code> in the current directory, load its contents, and then call <code>bagatto/parse-json</code> on them. The resulting attributes will then be the content of the site data associated with <code>:config-json</code>.</p> <pre><code class=clj>repl:17:&gt; (eval-data data)
@{:config-json @{&quot;subtitle&quot; &quot;A Very Good Blog.&quot; 
                 :path &quot;config.json&quot; 
                 :contents @&quot;{\&quot;subtitle\&quot;:\&quot;A Very Good Blog.\&quot;}\n&quot;}}
</code></pre> <p>We see that the resulting site data has a single entry, <code>:config-json</code>. The table associated with this entry has the two attributes we get for free&#8212;<code>:path</code> and <code>:contents</code>, which are the file path and contents, respectively&#8212;but that the call to <code>parse-json</code> has resulted in the key/value pairs inside the JSON file have been parsed and put in the site data too.</p> <h3 id=filewildcards>File Wildcards</h3> <p>The last way to specify data inputs is with wildcard references to multiple (potential) files. Under the hood, this relies on the <code>glob</code> function of <a href=https://github.com/andrewchambers/janet-sh>janet-sh</a>. There are two wildcard methods: <code>bagatto/*</code> and <code>bagatto/slurp-*</code>.</p> <h4 id=listmatchingfiles>List matching files</h4> <p>Use <code>bagatto/*</code> to provide a all the filenames that match the wildcard.</p> <pre><code class=clj>repl:24:&gt; (bagatto/eval-loader (bagatto/* &quot;demo/static/*&quot;))
@[&quot;demo/static/hello.png&quot;]
</code></pre> <p>Thus, we can use it as a data specification:</p> <pre><code class=clj>(def data {:static {:src (bagatto/* &quot;demo/static/*&quot;)
                    :attrs bagatto/parse-base}})
</code></pre> <pre><code class=clj>repl:27:&gt; (eval-data data)
@{:static @[@{:path &quot;demo/static/hello.png&quot;}]}
</code></pre> <p>Since we specified the <code>parse-base</code> parser, and used the basic form <code>bagatto/*</code> (which only lists files), we get an array of tables with the <code>:path</code> attribute only.</p> <p>This is the minimal case for listing files, but for files like the above, that only need to be copied into place, it&#8217;s all we need.</p> <h4 id=slurpmatchingfiles>Slurp matching files</h4> <p><code>bagatto/slurp-*</code> has the same wildcard functionality, but it also includes the contents of the matching files. We can use this to process files in more interesting ways.</p> <pre><code class=clj>repl:28:&gt; (bagatto/eval-loader (bagatto/slurp-* &quot;demo/posts/*.md&quot;))
@[(&quot;demo/posts/post.md&quot; @&quot;## A Post That You Might Be Interested In...&quot;) ...]
</code></pre> <p>The return value of the loader for each matching file is a two-tuple of the file&#8217;s path and contents. Notice that the contents of the markdown files include their own metadata in the form of YAML frontmatter.</p> <p>We can define a data specification based off of this loader. In this case we&#8217;ll specify the multimarkdown parser as the <code>attrs</code> callback. That will be able to extract the YAML frontmatter as additional metadata.</p> <pre><code class=clj>(def data {:posts {:src (bagatto/slurp-* &quot;demo/posts/*.md&quot;)
                   :attrs parse-mmarkdown}})
</code></pre> <pre><code class=clj>repl:33:&gt; (eval-data data)
@{:posts @[@{:path &quot;demo/posts/post.md&quot; :contents @&quot;...&quot;} 
           @{&quot;status&quot; &quot;post&quot; 
             :path &quot;demo/posts/post2.md&quot; 
             :contents @&quot;...&quot; 
             &quot;title&quot; &quot;A Really Good Title&quot;}]}
</code></pre> <p>Having evaluated the data specification, we can see that <code>:posts</code> is an array with one element for each file that matched the wildcard. Unlike with the single-file example above, <code>parse-mmarkdown</code> was then called for <em>each</em> post. I&#8217;ve collapsed the full contents so we can see that, since <code>post2.md</code> included a <code>title:</code> and <code>status:</code> attribute in its metadata, the <code>parse-mmarkdown</code> function has pulled that out and put it in the attributes for that post. <code>post.md</code> didn&#8217;t have any frontmatter, so it has no additional attributes.</p> <h4 id=transforms>Transforms</h4> <p>Since the wildcard loaders offer the ability to load multiple files, and the <code>attrs</code> callback operates on each file individually, Bagatto exposes one more element of the data specification: the <code>transform</code> callback. A transform, if specified, is called on the whole set of elements after each one has been parsed. This allows us to, for instance, sort a list of blog posts after they&#8217;ve been loaded and parsed.</p> <pre><code class=clj>(def data {:notes {:src (bagatto/slurp-* &quot;notes/*.md&quot;)
                   :attrs parse-note
                   :transform (bagatto/attr-sorter &quot;topic&quot;)}})
</code></pre> <p><a href=./api.html#bagattoattr-sorter><code>bagatto/attr-sorter</code></a> is exposed as a part of the Bagatto library and allows us to specify a key present in all the items, and sort the collection by it.</p> <h2 id=site>Site</h2> <p>The second and last value that your index module should define is <code>site</code>:</p> <pre><code class=clj>(def site ...)
</code></pre> <p>This is the <strong>site specification</strong>, which defines all the outputs of the system. Every site specification entry specifies either a single file, or a sequence of files, to be generated. To specify a file we must output the <strong>path</strong> it should be created at and the <strong>contents</strong> of the created file.</p> <p>The structure of the site specification is quite similar to the data specification: it&#8217;s an association between names and specification values. However, in this case the names don&#8217;t have any effect on the generated site; they&#8217;re just useful for the site author to organize their code.</p> <p>The relationship between <code>data</code> and <code>site</code> is simple but important to understand. The site specification is evaluated in the <em>context</em> of the site data, which is the output of the data specification (it&#8217;s what we see when we run <code>eval-data</code> above).</p> <p>A site specification isn&#8217;t actually a mapping data entries to pages; in most websites of any size, any given page will require data from more than one input (for instance, to display a <em>recent posts</em> sidebar on every page), and may well create more than one page out of the same input. Thus it&#8217;s useful to understand the overall flow of data in the system: Bagatto uses the data specification to create the site data, and then iterates through the site specification using the site data as the context, or evaluation evaluation environment, as it evaluates each entry in the specification. Each entry results in a sequence of one or more files to be written.</p> <h3 id=pathandcontentsliterals>Path and Contents Literals</h3> <p>As noted above, every site specification specifies the path and contents for one or more files to be created. Therefore, perhaps the simplest possible site is one consisting of a static path and contents:</p> <pre><code class=clj>repl:2:&gt; (def site {:_ {:dest &quot;out.txt&quot; :out &quot;Welcome to my website&quot;}})
{:_ {:dest &quot;out.txt&quot; :out &quot;Welcome to my website&quot;}}
</code></pre> <p>We can use <code>eval-site</code> to get an output of the path and contents of each file to be created. This is useful for debugging; in reality, site contents are generated using fibers, so this lets us peek under the hood to understand what our site specifications produce.</p> <p>Site specifications are evaluated in the context of site data, but in this case our only specification is completely static. therefore we can pass in an empty struct as the site data.</p> <pre><code class=cli>repl:4:&gt; (eval-site site {})
@[(:write &quot;out.txt&quot; &quot;Welcome to my website&quot;)]
</code></pre> <p>We can see that it plans to write a single file, with the specified path and contents.</p> <h3 id=rendererfunctions>Renderer functions</h3> <p>More useful is to pass a function as the specification contents, rather than a static value. This allows us to dynamically act on the input data in useful ways.</p> <p>A renderer function is simply any function which takes in the site data and outputs some file contents. We can write our own extremely simple one, which looks for a secret in the site data and outputs it in JDN format to a file. Then we can define a simple site specification with a static path that passes that function in directly as the <code>:out</code> attribute.</p> <pre><code class=clj>repl:6:&gt; (defn renderer [data] (string/format &quot;%j&quot; (data :secret)))
&lt;function renderer&gt;
repl:7:&gt; (def site {:_ {:dest &quot;out.txt&quot; :out renderer}})
{:_ {:dest &quot;out.txt&quot; :out &lt;function renderer&gt;}}
</code></pre> <p>Now, of course, we need to ensure that <code>:secret</code> is present in the site data. While, in practice, we&#8217;d have a data entry that defined <code>:secret</code>, it&#8217;s useful to note that for the purposes of inspecting our functions, we don&#8217;t need to use the output of the <code>eval-data</code> command. We can construct a struct directly.</p> <pre><code class=clj>repl:8:&gt; (eval-site site {:secret &quot;p@ssw0rd&quot;})
@[(:write &quot;out.txt&quot; &quot;\&quot;p@ssw0rd\&quot;&quot;)]
</code></pre> <p>The fact that the site data is a simple key-value structure, and the renderer output is just a string, makes it very simple to understand how data flows through the application and to extend it.</p> <p>Perhaps a slightly more realistic example would be one that combines data from more than one source.</p> <pre><code class=clj>repl:12:&gt; (defn renderer [data] string/format &quot;%s:%j:%f&quot; 
                                              (get-in data [:config :prefix]) 
                                              (get-in data [:personal :password]) 
                                              (math/random)))
&lt;function renderer&gt;
repl:14:&gt; (def site {:_ {:dest &quot;out.txt&quot; :out renderer}})
{:_ {:dest &quot;out.txt&quot; :out &lt;function renderer&gt;}}
repl:15:&gt; (eval-site site {:personal {:password &quot;p@ssw0rd&quot;} 
                                   :config {:prefix &quot;md5&quot;}})
@[(:write &quot;out.txt&quot; &quot;md5:\&quot;p@ssw0rd\&quot;:0.487181&quot;)]
</code></pre> <p>Here we see the very common case of combining data from multiple sources into a single file&#8217;s contents.</p> <h3 id=siteselectors>Site Selectors</h3> <p>We saw that, using data specifications, we can select <em>source files</em> to be included in our site data with wildcards. A very common example of this would be building a blog; in addition to all the static content and any config files, we&#8217;d want to load up all the blog posts in a directory, and to be able to add a new post simple by adding a file to the directory, without changing the config.</p> <p>Thus, it will be very common that in addition to rendering pages based on static config data or files, we&#8217;ll want to iterate through all the files that match a wildcard and render one output file for each (eg., rendering a <code>post.html</code> for each source file).</p> <p>For that we can use <strong>site selectors</strong>.</p> <h4 id=:each><code>:each</code></h4> <p>Given some site data with a series of named data entries, we can use the <code>each</code> attribute to refer to one of those entries. Bagatto will then call the <code>dest</code> and <code>out</code> functions on each file in the entry.</p> <p>Because there&#8217;s now an additional piece of data in addition to the site data, the renderer and path generator functions in an <code>each</code> specification take two arguments: the site data <code>data</code>, and then the individual element <code>item</code>.</p> <p>We can see an example. First let&#8217;s define a data specification with a wildcard, so we have something to iterate over:</p> <pre><code class=clj>repl:55:&gt; (def data {:users {:src (bagatto/slurp-* &quot;users/*&quot;) 
                             :attrs bagatto/parse-json} 
                     :config {:attrs {:prefix &quot;pw::&quot;}}})
{:config {:attrs {:prefix &quot;pw::&quot;}} :users {:attrs &lt;function parse-json&gt; :src &lt;fiber 0x55F89DCCE930&gt;}}
</code></pre> <p>The <code>users</code> directory will have two JSON files in it. Therefore, since we specify <code>bagatto/parse-json</code> as the parser for <code>users</code>, we can expect the <code>users</code> site data to contain an array of 2 tables that have been decoded from the JSON.</p> <p>Next we&#8217;ll define a renderer function. Like above, it will draw from multiple sources; but this time, it will take two arguments, because we intend it to be called on each element in <code>users</code>.</p> <pre><code class=clj>repl:34:&gt; (defn renderer [data item] (string/format &quot;%s%s&quot; 
                                      (get-in data [:config :prefix]) 
                                      (item &quot;password&quot;)))
</code></pre> <p>As before we expect <code>data</code>, but now we expect <code>item</code> as well. For each call <code>data</code> will be the same site data, and item will be a different element.</p> <p>Finally we will define a site specification that uses <code>:each</code> to refer to the <code>users</code> site data.</p> <pre><code class=clj>repl:35:&gt; (def site {:_ {:each :users 
                         :dest (bagatto/path-copier &quot;passwords/&quot;) 
                         :out renderer}})
{:_ {:dest &lt;function 0x55F89DCBC880&gt; :out &lt;function renderer&gt; :each :users}}
</code></pre> <p><code>:each :users</code> will cause Bagatto to call the renderer once for each item in <code>:users</code>. In addition, we now need to specify an actual function for <code>:dest</code>. If we left it as a static value, the contents would be repeatedly written to the same file, which is obviously not what we want. Here we use the <a href=./api.html#bagattopath-copier><code>bagatto/path-copier</code></a> helper, which gives us a function that will accept any file and return a new path with the base we specify.</p> <p>We can evaluate the data spec, and use that to evaluate the site spec:</p> <pre><code class=clj>repl:56:&gt; (eval-site site (eval-data data))
@[(:write &quot;passwords/alice.json&quot; &quot;pw::1234&quot;) 
  (:write &quot;passwords/bob.json&quot; &quot;pw::snoopy&quot;)]
</code></pre> <p>It&#8217;s produced two write plans, one for each user file, whose contents are interpolated from the contents of their respective source files.</p> <h4 id=copyingfiles>Copying Files</h4> <p>A very common operation when generating a website is to copy a source file without touching it. If Bagatto receives a site specification with a site selector and a <code>:dest</code> entry, but no <code>:out</code> entry, it will interpret that as a <strong>copy</strong> operation. It will read the <code>:path</code> of whatever item or item it receives (this attribute is always present), and copy it to the <code>:dest</code> attribute of the site specification.</p> <p>Here&#8217;s a super simple data spec:</p> <pre><code class=clj>repl:62:&gt; (def data {:users {:src (bagatto/* &quot;users/*&quot;) :attrs bagatto/parse-base}})
{:users {:attrs &lt;function parse-base&gt; :src &lt;fiber 0x55F89DD25A00&gt;}}
</code></pre> <p>We use <code>bagatto/*</code> instead of <code>bagatto/slurp-*</code>, which just lists the files, but doesn&#8217;t read them. We also use <code>bagatto/parse-base</code> as our parser, which just returns the base <code>:path</code> attribute.</p> <p>We can now define a <code>site</code> that simply refers to <code>:users</code> and specifies a path without specifying contents.</p> <pre><code class=clj>repl:58:&gt; (def site {:_ {:each :users :dest (bagatto/path-copier &quot;passwords/&quot;)}})
{:_ {:dest &lt;function 0x55F89DCD8B30&gt; :each :users}}
</code></pre> <p>Evaluating the site produces two copy instructions to the new paths:</p> <pre><code class=clj>repl:63:&gt; (eval-site site (eval-data data))
@[(:copy &quot;users/alice.json&quot; &quot;passwords/alice.json&quot;) 
  (:copy &quot;users/bob.json&quot; &quot;passwords/bob.json&quot;)]
</code></pre> <h2 id=templates>Templates</h2> <p>Of course, most websites are not made by <code>string/format</code>ing HTML together; they use HTML templates. The template system used by Bagatto is <a href=https://git.sr.ht/~bakpakin/temple>Temple</a>. Temple is a wonderfully powerful and simple templating system that should be very enjoyable to use.</p> <h3 id=templebasics>Temple Basics</h3> <p>Here&#8217;s the contents of <code>post.temple</code> in the Bagatto demo directory:</p> <pre><code class=html>{$ (import ./base_top) $}
{% (base_top/render-dict args) %}
      
      &lt;h1&gt;{{ (get-in args [:_item :title]) }}&lt;/h1&gt;
      &lt;p class=&quot;post-info&quot;&gt;
        {{ (get-in args [:_item :date]) }}
      &lt;/p&gt;
      {- (bagatto/mmarkdown-&gt;html (get-in args [:_item :contents])) -}

{$ (import ./base_bottom :as base_bottom) $}
{% (base_bottom/render-dict args) %}
</code></pre> <p>The appeal of Temple is in its simplicity. It consists of four types of expression, all of which are seen here.</p> <ul> <li><code>{$ ... $}</code>: Evaluate the expression between the <code>$</code>s at compile time;</li> <li><code>{% ... %}</code>: Evaluate the expression between the <code>%</code>s at runtime, escape and interpolate the output;</li> <li><code>{- ... -}</code>: Evaluate the expression between the <code>-</code>s at runtime, interpolate the output without escaping it.</li> <li><code>{{ ... }}</code>: Evaluate and interpolate the expression inside the curly braces.</li> </ul> <p>While many other templating languages differentiate between capturing and non-capturing by differentiating between their escape brace types (which means having to change brace types from line to line, even within the same syntactic expression), Temple is non-capturing by default, and we interpolate into the surrounding template by printing to stdout. In other words, to interpolate something into a Temple template, simply use <code>print</code>:</p> <pre><code class=html>Welcome to my web page. Here's a pretty-printed example 
of one of my favorite data structures:

{% (print (string/format &quot;%q&quot; {:name &quot;Bowler Cat&quot; 
                               :species &quot;Felis Domesticus&quot;})) %}

Ain't she a beaut?
</code></pre> <p>We can think of <code>{{ foo }}</code> as syntactic sugar for <code>{% (print foo) %}</code>.</p> <p>Temple templates accept a single dictionary of arguments, which is bound inside the template to <code>args</code>.</p> <h3 id=usingtempleinbagatto>Using Temple in Bagatto</h3> <p>Bagatto adds a very thin layer of functionality and convenience on top of Temple. The first thing it does is it extends the Temple environment with the same libraries that are listed at the beginning of this manual. Thus we can call <code>bagatto/</code> helper functions from within a template.</p> <p>The only other change it makes is to ensure the presence, if applicable of the <code>item</code> passed in as the second argument to site spec functions, which contains the attributes of the individual element of an <code>:each</code> selection. Those attributes are made available at <code>(args :_item)</code>. For instance, in the example above, we expect the attributes of the specific blog post being rendered to be present in the <code>:_item</code> value, and so we refer to it to get the title, date and contents of the post.</p> <h3 id=renderingatemplate>Rendering a Template</h3> <p>The basic call to render a template is <a href=./api.html#bagattorender><code>bagatto/render</code></a>. This allows us to directly invoke a template by name, with site data and an optional item, and returns the fully rendered template. For instance, if we have a simple template at <code>templates/simple.temple</code>:</p> <pre><code>I am known for my {{ (args &quot;topic&quot;) }} skills.
</code></pre> <p>Then we can render out page contents like so:</p> <pre><code>repl:5:&gt; (bagatto/render &quot;templates/simple&quot; {&quot;topic&quot; &quot;Web Design&quot;})
@&quot;I am known for my Web Design skills.\n&quot;
</code></pre> <p>In a proper web page, of course, our template file would contain HTML with placeholders for the values to be interpolated.</p> <h3 id=renderergenerators>Renderer Generators</h3> <p>Because <code>bagatto/render</code> is such a common operation, Bagatto offers a <a href=./api.html#bagattorenderer>convenience function</a> that will generate a <strong>renderer</strong> that will make the above call. For instance, if I wanted to specify the above template in a site specification, I&#8217;d probably write this:</p> <pre><code class=clj>repl:6:&gt; (def site {:_ {:dest &quot;out.txt&quot; 
                        :out (bagatto/renderer &quot;templates/simple&quot;)}})
{:_ {:dest &quot;out.txt&quot; :out &lt;function 0x55DAC976C660&gt;}}
</code></pre> <p>Thus I avoid having to write a new renderer function for each <code>:out</code> entry, if I&#8217;m just going to pass on the data to a specific template. Evaluating the site we get the same thing:</p> <pre><code class=clj>repl:7:&gt; (eval-site site {&quot;topic&quot; &quot;Web Design&quot;})
@[(:write &quot;out.txt&quot; @&quot;I am known for my Web Design skills.\n&quot;)]
</code></pre> <h2 id=filters>Filters</h2> <p>A site spec with an <code>:each</code> can include a <code>:filter</code> attribute, too. This can be any predicate function which takes the site and an individual item from the spec&#8217;s site selector, and returns true or false. If the return value is false, the site spec will skip that elements.</p> <p>This can be very useful when handling an input of mixed files. For instance, with a <code>static/</code> directory that contains both CSS and supplementary HTML files, we might want to have different render steps for each. We could then write two site specs, that both take that data entry in their <code>:each</code>, but have different <code>:filter</code> attributes (we could also have written two different wildcards in two different data specs, but hopefully you get my point).</p> <h1 id=extendingbagatto>Extending Bagatto</h1> <p>Bagatto bills itself as a &#8220;transparent&#8221; static site generator. By this we mean: we should favor <em>first-class functions</em> over <em>configuration</em>, and <em>native terms and data structures</em> over <em>indirect control flow</em> whenever possible.</p> <p>Here&#8217;s a simple example: Bagatto creates files by combining a <em>file path</em> with some <em>file contents</em>. The values that can go in the <code>:out</code> section of a site specification can either be strings, or functions which produce strings.</p> <p>We might be tempted as application authors to introduce a layer of abstraction in front of the render process and ask the user to specify the <em>name</em> of a render function built into Bagatto. This would provide a simple, convenient DSL. Unfortunately, it has the very unfortunate side effect of effectively walling off that function from a site author. If&#8212;when&#8212;the author needs to understand what specifically is being passed into the render function, or needs to tweak its output slightly, they&#8217;re out of luck. The logic that reads this name, translates it into a render function, calls the function with some inputs and uses the output is all stuck within the belly of Bagatto and the author might need to recompile the whole application to get into it.</p> <p>Similarly, if they want to introduce a new renderer&#8212;a new template language for instance&#8212;they can only do so by introducing the function directly into Bagatto, giving it a name, and then passing the name in a site specification.</p> <p>Therefore we keep the operation of the renderer within inspection of the author. By specifying a literal function, we can easily wrap other functions and debug their output or change it. Similarly, we do attempt to offer an author the same level of convenience as the above DSL; but instead of offering them the ability to name a function that we control, we offer them the ability to call a function that outputs the renderer function itself, so that they still have access to its inputs and outputs.</p> <p>Thus, we have a pretty straightforward way to write our own loaders, attributes, path-generator and renderer functions.</p> <p>Each of the below entries will have a typespec describing the signature of the functions that can be implemented. This isn&#8217;t meaningful Janet, but hopefully gives a succinct picture of the types that will be meaningful.</p> <h2 id=loaders>Loaders</h2> <pre><code>(let [element (or 'source-path '(source-path file-contents))]
 (defn loader [] 
  (or '{:each (element ...)} '{:some element)}))
</code></pre> <p>The <code>:src</code> attribute in a data spec can take a 0-arity function which, when called, returns one of two types of values:</p> <h3 id=:eachvalues><code>{:each values}</code></h3> <p><code>values</code> is any indexable data structure, the elements of which are either two-tuples or single values. Two-tuples will be treated by the base attribute parser as <code>[source-path file-contents]</code>. Single values will be treated as <code>source-path</code> only.</p> <h3 id=:somevalue><code>{:some value}</code></h3> <p><code>value</code> is a single instance of the above value type: either a two-tuple or a single path value.</p> <p>We could, for instance, write a custom loader function that accepted a URL, made a web request, and returned a (file-url file-contents) tuple.</p> <h2 id=parsers>Parsers</h2> <pre><code>(defn parser [contents attrs] attrs)
</code></pre> <p><code>:attrs</code> can take any parser function. The purpose of a parser is to transform the individual outputs of a data loader into an attributes table. There are two attributes that are guaranteed to be present when the parser is called, <code>:path</code> and <code>:contents</code>. A parser function shouldn&#8217;t remove either of these attributes, but can use them to generate new ones. For instance, if <code>contents</code> is unparsed Markdown with YAML frontmatter, then a parser function could extract metadata from the frontmatter and return an updated attributes table with those arbitrary metadata.</p> <p><code>contents</code> and the <code>:contents</code> attribute can be expected to be identical, and the former is provided as a convenience.</p> <p>An example of a custom parser would be one that shelled out to <a href=https://asciidoctor.org/ >Asciidoctor</a> to extract attributes from an asciidoc document.</p> <h2 id=pathgenerators>Path Generators</h2> <pre><code>(defn each-parser [data item] path)
(defn some-parser [data] path)
</code></pre> <p>In the site specification, <code>:dest</code> can take any function which returns a file path string. If the spec has an <code>:each</code>, the generator function should take the site data and the individual item as arguments, and return the destination path for the individual item.</p> <p>Otherwise, it should take the site data as a single argument and return the destination path for its entry output.</p> <h2 id=renderers>Renderers</h2> <pre><code>(defn each-renderer [data item] file-contents)
(defn some-renderer [data] file-contents)
</code></pre> <p><code>:out</code> takes any renderer function&#8212;these work along exactly the same lines as path generators. If the site spec has an <code>:each</code>, the function should take two arguments, otherwise it should take one. The return value of the function will be written directly to the file path in its site spec.</p> <p>Following from the parser example above, an example custom renderer could take an asciidoc document and shell out to Asciidoctor to render it into HTML.</p> </div> </div> </div> <footer class="footer pv5 ph3 pa6-ns mt5 dt-l w-100 lh-copy"> <div class> Z. D. Smith, Brooklyn, 2020 </div> <div class="dtc-l tr-l mt2 mt0-l"> Built with Bagatto. </div> </footer> </body> </html> 